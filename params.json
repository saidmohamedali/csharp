{"name":"Csharp(C#) Main Topics","tagline":"(This page is under construction) Welcome to this C# Main Topics Document. Here you will find C# (pronounced C Sharp) key topics summaries and links for better knowledge","body":"Every one can be a C# developer but being a good developer meant to constantly review some key topics.\r\nThis page is not **tutorial for c#**, it is more like \"**did you know that...?**\".\r\nTopics are not exhaustive but they are essential and organized like a check-list.\r\n\r\n# Generics\r\n\r\nGenerics provide type safety without the overhead of multiple implementations.\r\nIt offers the ability to write a single class that other client code can use without incurring the cost or risk of runtime casts or boxing operations.\r\nBut there are few thinks to keep in mind while using generics.\r\n\r\nScenario:_**Why does this code not compile?**_\r\n```csharp\r\npublic class Generic<T>\r\n{\r\n    public T Field; \r\n    public T AddSub()\r\n    {\r\n        T i = Field + 1;\r\n    }\r\n}\r\n```\r\n\r\n_**The answer is:**_ the ** + operator** is not defined for T.\r\nFor further information, please visit: \r\n*[Generics](http://msdn.microsoft.com/en-us/library/c6cyy67b%28v=vs.90%29.aspx).\r\n\r\n## Constraints\r\n\r\nScenario1:_**Why does this code not compile?**_\r\n```csharp\r\n class CustomFactory<T> \r\n    {\r\n        public T CreateItem()\r\n        {\r\n            return new T();\r\n        }\r\n    }\r\n```\r\n\r\n_**The answer is**_ : CreateItem Methode tries to  instantiate a new object of type T and the compile does not now if there is a parameter-less constructor of type T so to make it work we need add **new** constraint to this generic class.\r\nFor further information, please visit: \r\n* [New constraint](http://msdn.microsoft.com/en-us/library/sd2w2ew5.aspx)\r\n\r\nScenario2:_**What will be printed on the Console and Why?**_\r\n```csharp\r\npublic static void PrintAreEqual<T>(T s, T t) where T : class\r\n{\r\nSystem.Console.WriteLine(s == t);\r\n}\r\nstatic void Main()\r\n{\r\nstring s1 = \"target\";\r\nSystem.Text.StringBuilder sb = new System.Text.StringBuilder(\"target\");\r\nstring s2 = sb.ToString();\r\nPrintAreEqual<string>(s1, s2);\r\nConsole.Read();\r\n}\r\n```\r\n\r\n_**The answer is**_ : False.  Using **where T : class constraint** induce that == will check reference equality and not value equality.\r\nFor further information, please visit: \r\n* [constraint](http://msdn.microsoft.com/en-us/library/d5x73970.aspx)\r\n\r\nScenario3:_**Why does this code compile?**_\r\n```csharp\r\nclass A { public A() { } }\r\nstruct C {  }\r\nclass D<T> where T : new()\r\n{  \r\nD<A> c1 = new D<A>();  \r\nD<C> c3 = new D<C>();  \r\n}\r\n```\r\n_**The answer is**_ : struct C is a value-type, Unlike classes, structs can be instantiated without using a new operator.\r\n\r\n\r\n## Generic Collections\r\nA generic collection enforces type safety so that no other data type can be added to it. When you retrieve an element from a generic collection, you do not have to determine its data type or convert it.\r\nThe classes in the System.Collections namespace do not store elements as specifically typed objects, but as objects of type Object.\r\n\r\nSome useful Generic collections:\r\n* LinkedList<T> is a general-purpose linked list that provides O(1) insertion and removal operations.\r\n* SortedDictionary<TKey, TValue> is a sorted dictionary with O(log n) insertion and retrieval operations, which makes it a useful alternative to SortedList<TKey, TValue>.\r\n* KeyedCollection<TKey, TItem> is a hybrid between a list and a dictionary, which provides a way to store objects that contain their own keys.\r\n* BlockingCollection<T> implements a collection class with bounding and blocking functionality.\r\n* ConcurrentBag<T> provides fast insertion and removal of unordered elements.\r\n\r\n\r\nFor further information, please visit: \r\n* [Generic collections](http://msdn.microsoft.com/fr-fr/library/ms172181%28v=vs.110%29.aspx)\r\n* [when to use collections](http://msdn.microsoft.com/en-us/magazine/cc163377.aspx)\r\n\r\n## Variance\r\n\r\nScenario1: _**Why does this code not compile?**_\r\n```csharp\r\nList<int> ints = new List<int>();\r\nints.Add(1);\r\nints.Add(10);\r\nints.Add(42);\r\nList<object> objects = new List<object>();\r\nobjects.AddRange(ints);\r\n\r\n```\r\n_**The answer is**_ : Generic collections are strongly type, event if **int** is convertible to **object**, `List<int>` are not `List<object>`. There is simple workarround:\r\n\r\n`AddRange<int, object>(ints, objects);`\r\n\r\n```csharp\r\npublic static void AddRange<S, D>(List<S> source, List<D> destination)\r\n        where S : D\r\n        {\r\n            foreach (S sourceElement in source)\r\n            {\r\n                destination.Add(sourceElement);\r\n            }\r\n        }\r\n```\r\nA generic interface or delegate is called variant if its generic parameters are declared covariant or contravariant\r\nFor further information, please visit: \r\n* [Variance](http://msdn.microsoft.com/fr-fr/library/ms228359%28v=vs.90%29.aspx)\r\n\r\nScenario2:_**What king of runtime exception do we get with code above?**_\r\n```csharp\r\n class Instrument {\r\n        public override string ToString()\r\n        {\r\n            return \"I am simple Instrument\";\r\n        }\r\n    }\r\n    class Index:Instrument {\r\n        public override string ToString()\r\n        {\r\n            return \"I am an Index\";\r\n        }\r\n    }\r\n    class IndexOption : Index {\r\n        public override string ToString()\r\n        {\r\n            return \"I am an option over Index\";\r\n        }\r\n    }\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            Index l_index = new Index();\r\n            Instrument l_instrument = l_index;\r\n\r\n            Console.WriteLine(l_instrument);\r\n\r\n            IndexOption l_indexOption = new IndexOption();\r\n            l_instrument = l_indexOption;\r\n            Console.WriteLine(l_instrument);\r\n\r\n            Instrument[] l_instruments = new Instrument[3];\r\n            l_instruments[0] = new Index();\r\n            l_instruments[1] = new Instrument();\r\n            l_instruments[2] = new IndexOption();\r\n            for (int l_i = 0; l_i < l_instruments.Length; ++l_i)\r\n                Console.WriteLine(string.Format(\"array[{0}]={1}:\", l_i, l_instruments[l_i]));\r\n\r\n            Instrument[] l_instruments2 = new IndexOption[3];\r\n            l_instruments2[0] = new Index(); \r\n            l_instruments2[1] = new Instrument();\r\n            l_instruments2[2] = new IndexOption();\r\n            for (int l_i = 0; l_i < l_instruments2.Length; ++l_i)\r\n                Console.WriteLine(string.Format(\"array[{0}]={1}:\", l_i, l_instruments2[l_i]));\r\n            Console.Read();\r\n        }\r\n\r\n    }\r\n\r\n```\r\n\r\n_**The answer is**_ : **System.ArrayTypeMismatchException** with theses lines:   \r\n```csharp\r\nl_instruments2[0] = new Index(); \r\nl_instruments2[1] = new Instrument();\r\n```\r\nAn Index object and IndexOption are Instrument because of Implicit Conversion: **covariance**  but when it came to array, we better not forget that  **covariance**  is not type safe. Run-time failure is due to run-time type checking when assign operation actually happen. Array methods are not covariante.\r\nIn this scenario we should add extra method in order to be able to add **Instrument** or **Index** into **l_instruments2** array.\r\n\r\n\r\n* [Covariance - Contravariance in french](http://sebastiencourtois.wordpress.com/2010/04/14/nouveauts-c-net-4-introduction-la-covariance-contravariance)\r\n* [Covariance - Contravariance](http://msdn.microsoft.com/en-us/library/ee207183.aspx)\r\n\r\n# Expressions\r\n* [Expression Trees](http://msdn.microsoft.com/fr-fr/library/bb397951.aspx)\r\n* [Expression Trees Basics](http://blogs.msdn.com/b/charlie/archive/2008/01/31/expression-tree-basics.aspx)\r\n* [Dynamic Expression Trees](http://blogs.msdn.com/b/csharpfaq/archive/2009/09/14/generating-dynamic-methods-with-expression-trees-in-visual-studio-2010.aspx)\r\n* [Lambda Expressions](http://msdn.microsoft.com/fr-fr/library/bb397687.aspx)\r\n\r\nJust few thing to keep in mind for Expression trees\r\n-need to be compiled with **Compile()** method\r\n-need to be run with (parameter(s)) or ()\r\nExample:\r\n````csharp\r\nint l_result = Expression.Lambda<Func<int, int>>(block, value).Compile()(5);\r\n````\r\n\r\n## Operators\r\n\r\n* [C# Operators](http://msdn.microsoft.com/en-us/library/ms173145.aspx)\r\n\r\n## Query Expressions\r\n* [C# Queries](http://msdn.microsoft.com/fr-fr/library/bb384065.aspx)\r\n\r\n\r\n# Arrays and Collections\r\n## Array and Collection Usage\r\n# Class Members\r\n## Readonly and Constant Fields\r\n## Modifiers\r\n## Static/Instance Members\r\n## Properties and Indexers\r\n## Methods\r\n# Reference and Value Types\r\n## Classes and Structs\r\n## Primitive Datatypes\r\n## Boxing and Unboxing\r\n# Resources and COM\r\n## Unmanaged Resources\r\n## Platform Invoke (P/Invoke)\r\n# Flow of control\r\n## Jump Statements\r\n## Selection Statements\r\n## Iteration Statements\r\n# Delegates and Events\r\n## Event Creation and Usage\r\n## Asynchronous Processing\r\n## Action and Func\r\n# Exceptions\r\n## Exception Handling\r\n## Rethrowing Exceptions","google":"C#, c#, csharp, .net","note":"Don't delete this file! It's used internally to help with page regeneration."}